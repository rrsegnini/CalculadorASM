
%include "io.mac"

;;----------------------------------------------------------------
;;----------------------------------------------------------------
%macro	checkFloat 1
	mov 	CX, 263
	mov	EDX, 1
	mov 	EAX, 0
	
check:
	mov 	AL, byte[%1 + EDX]
	cmp	AL, '.'
	je	TRUE
	inc	EDX
	loop	check
	jmp	FALSE
TRUE:
	mov	EAX, 'True'
	jmp	SALIR
FALSE:
	jmp	SALIR
	
SALIR:
	nwln
	
%endmacro

;;----------------------------------------------------------------
;;----------------------------------------------------------------

%macro	bF_dF 	2	;Binary in floating point to decimal
	mov 	CX, 263
	mov	EDX, 0
	mov 	EAX, 0
	mov	EBX, 0	;RESULTADO
	mov	dword[frac], 0	;RESULTADO FRACCIONARIO
		
recorrer:
	;PutLInt	dword[frac]
	mov 	AL, byte[%1 + EDX]

	cmp	AL, '.'		;SALIR SI LLEGA AL FINAL DEL STRING
	je	bF_dF_frac

	sub	AL, '0'
	nwln
	

	call	pow
	
	;PutLInt	EBX
	nwln

	inc	EDX
	loop	recorrer
	jmp	bF_dF_salir
	

pow:
	push	CX
	push	EDX


	cmp	EDX, 0
	je	pow_primero


	;PutLInt	EDX

	
	cmp	AL, 1
	je	Uno
	jmp	Cero

Uno:
	shl	EBX, 1
	add	EBX, EAX

	pop 	EDX
	pop	CX
	jmp	pow_salir

pow_primero:
	inc 	EDX
	cmp	AL, 1
	je	Uno

Cero:


	
	shl	EBX, 1

	pop	EDX
	pop	CX

	
pow_salir:
	ret
	


bF_dF_frac:
	mov	SI, 1
	;PutInt	SI
	;push	S
bF_dF_frac_2:

	inc	EDX
	push	EDX
	;PutLInt	EDX
	nwln
	mov	EAX, 0
	mov 	AL, byte[%1 + EDX]
	PutCh	AL
	;nwln
	cmp	AL, 0		;SALIR SI LLEGA AL FINAL DEL STRING
	je	bF_dF_salir
	
	
	cmp	AL, '1'
	je	Uno_frac
	cmp	AL, '0'
	je	Cero_frac
	jmp	Frac_loop

Uno_frac:
	
	mov	EAX, 5
	mul	SI
	;PutInt	SI
	;nwln
	mov	SI, AX

	;PutInt	SI
	;nwln	
	add	word[%2], SI
	;PutLInt	%2
	;mov	dword[%2], EAX

;jmp	bF_dF_salir

	jmp	Frac_loop
	
Cero_frac:
	mov	EAX, 5
	mul	SI
	mov	SI, AX
	;PutInt	AX
	;nwln
Frac_loop:
	pop	EDX
	loop	bF_dF_frac_2
		
		 
bF_dF_salir:
	nwln	
	
%endmacro

;;----------------------------------------------------------------
;;----------------------------------------------------------------

%macro	b_h	1	;number
	mov 	CX, 263
	mov	EDX, 1 
	mov 	EAX, 0
	mov	EBX, 0
read_str:
	mov	EAX, dword[%1 + EDX]
	;mov	[digit], EAX
	;PutStr	digit
	cmp	EAX, 0
	je	SALIR

	cmp 	EAX, '1010'
	je	A
	cmp	EAX, '1011'
	je	B
	cmp	EAX, '1100'
	je	C
	cmp	EAX, '1101'
	je	D
	cmp	EAX, '1110'
	je	E
	cmp	EAX, '1111'
	je	F
	;jmp	read_str2

	jmp	de0_9

read_str2:
	loop 	read_str
	jmp	SALIR
	 

de0_9:
	sub	EAX, 185
	jmp	read_str2
	;PutLInt	EAX
		


A:
	PutCh 	'A'
	add	EDX, 4
	jmp 	read_str2
B:
	PutCh 	'B'
	add	EDX, 4
	jmp 	read_str2
C:
	PutCh 	'C'
	add	EDX, 4
	jmp 	read_str2
D:
	PutCh 	'D'
	add	EDX, 4
	jmp 	read_str2
E:
	PutCh 	'E'
	add	EDX, 4
	jmp 	read_str2
F:
	PutCh 	'F'
	add	EDX, 4
	jmp 	read_str2


SALIR:
	nwln
	;ret
	


%endmacro



;;----------------------------------------------------------------
;;----------------------------------------------------------------
%macro	powOchoASCII 1

	pushfd	;Conservar el estado de todos los registros de 32bits
	

	mov	BH, %1
	
	cmp	BH, 0
	je	pow_cero
	cmp	BH, 1
	je	pow_uno

sum_loop_1:
	mov	BL, 8
sum_loop:
	mov	ESI, 9
	mov	ECX, 10
	clc
add_loop:
	mov	AL, [ocho1+ESI]
	adc	AL, [ocho2+ESI]
	aaa
	pushf
	or	AL, 30h
	popf
	mov	[potencia+ESI], AL
	dec	ESI
	loop	add_loop
	;mov	[potencia+ESI], 
	;PutStr	sum_msg
	;PutStr	potencia
	;nwln
	

	cmp	BL, 2
	je	Repetir
	dec	BL
	
	
nwln
	mov	ECX, 0
	push	EDX
mover_operando:
	
	
	
	mov	DL, byte[potencia+ECX]
	mov	byte[potencia+ECX],  '0'
	;PutCh	DL
	;nwln
	mov	byte[ocho1+ECX], DL
	;sub	[potencia], ECX
	
	;PutStr	number1
	;nwln
	inc	CX
	cmp	CX, 10
	je	salir_mover_operandos
	jmp	mover_operando

salir_mover_operandos:
	pop 	EDX
	jmp	sum_loop




	
Repetir:
	
	cmp	BH, 2
	je	SALIR_pow
	dec	BH
	mov	ECX, 0
mover_operandos_2:

	push	EDX
	mov	DL, byte[potencia+ECX]
	mov	byte[potencia+ECX],  '0'
	mov	byte[ocho1+ECX], DL
	mov	byte[ocho2+ECX], DL

	;PutStr	ocho1
	;nwln
	;PutStr	ocho2

	inc	CX
	cmp	CX, 10
	je	salir_mover_operandos_2
	jmp	mover_operandos_2

salir_mover_operandos_2:
	pop EDX
	jmp	sum_loop_1


pow_cero:
	mov	byte[potencia + 9], '1'
	jmp SALIR_pow

pow_uno:
	
	mov	byte[potencia + 9], '8'
	

SALIR_pow:
	popfd
%endmacro

;;----------------------------------------------------------------
;;----------------------------------------------------------------
%macro stringToInt 1

reading:
     sub     EAX, EAX
     mov     EBX, %1
     
cond:   
     mov     DX, 10
     cmp     byte[EBX], 0
     je      question
     
   
     sub     byte[EBX], '0'
     mul     EDX
     sub     ECX, ECX
     mov     CL, byte[EBX]
     add     EAX, ECX
     inc     EBX 
     jmp cond

question:
     PutLInt EAX
     nwln
 
     jmp done


done:
     


%endmacro

;;----------------------------------------------------------------
;;----------------------------------------------------------------
%macro	mulASCII 2

	;pushfd	;Conservar el estado de todos los registros de 32bits
	
	mov	EBX, %2
	cmp	EBX, 1
	je	Uno_mul

	cmp	EBX, 0
	je	SALIR_mul_2
	
	mov	ECX, 0
copiar_num_mul:
	;push	EDX
	mov	DL, byte[%1+ECX]
	mov	byte[number2+ECX], DL
	
	inc	CX
	cmp	CX, 10
	je	sum_loop_mul
	jmp	copiar_num_mul



sum_loop_mul:
	mov	ESI, 9
	mov	ECX, 10
	clc
add_loop_mul:
	mov	AL, [%1+ESI]
	adc	AL, [number2+ESI]
	aaa
	pushf
	or	AL, 30h
	popf
	mov	[sum+ESI], AL
	dec	ESI
	loop	add_loop_mul
	;mov	[sum+ESI], 
	PutStr	sum_msg
	PutStr	sum
	nwln
	

	cmp	EBX, 2
	je	SALIR_mul
	dec	EBX
	
	;push	ECX	;Para conservar el ECX
	;PutStr	sum
nwln
	mov	ECX, 0
mover_operando_mul:
	
	
	;push	EDX
	mov	DL, byte[sum+ECX]
	mov	byte[sum+ECX],  ' '
	;PutCh	DL
	;nwln
	mov	byte[%1+ECX], DL
	;sub	[sum], ECX
	
	PutStr	number1
	nwln
	inc	CX
	cmp	CX, 10
	je	salir_mover_operandos_mul
	jmp	mover_operando_mul

salir_mover_operandos_mul:
	;pop 	EDX
	jmp	sum_loop_mul


Uno_mul:
	mov	ECX, 0
Uno_mul_2:	
	
	mov	DL, byte[%1+ECX]
	mov	byte[sum+ECX], DL
	
	inc	CX
	cmp	CX, 10
	je	SALIR_mul
	jmp	Uno_mul_2
	


SALIR_mul:
	mov	ECX, 0
SALIR_mul_1:
	
	mov	DL, byte[sum+ECX]
	mov	byte[sum+ECX],  '0'
	mov	byte[%1+ECX],  '0'
	mov	byte[total+ECX], DL
	
	inc	CX
	cmp	CX, 10
	je	SALIR_mul_2
	jmp	SALIR_mul_1
	
SALIR_mul_2:

	
%endmacro






